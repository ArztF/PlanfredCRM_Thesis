\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{pics/express_logo.png}
    \caption{Express.js Logo}
    \label{fig:enter-label}
\end{figure}
Express.js ist ein hoch angesehenes Node.js-Framework, das erstmals im November 2010 veröffentlicht wurde. Trotz seiner minimalistischen Ausrichtung zeichnet sich Express durch seine Erweiterbarkeit und Vielseitigkeit aus. Dies wird durch eine Fülle von Libraries und Modules ermöglicht, die in das Framework integriert sind oder von der Entwicklergemeinschaft entwickelt wurden. Diese Ressourcen erleichtern die Bewältigung komplexer Aufgaben, wie die Handhabung von Cookies, Sitzungsverwaltung, Benutzeranmeldung und viele weitere Funktionen, die für moderne Webanwendungen, von entscheidender Bedeutung sind.
\newline
Eine der architektonischen Merkmale von Express ist sein Middleware-Konzept. Dieses ermöglicht die Verarbeitung von HTTP-Anfragen in Schichten. Jede Middleware-Funktion kann spezifische Aufgaben übernehmen und ist in der Lage, Requests und Responses zu modifizieren oder zu ergänzen, bevor sie an die nächste Middleware-Funktion weitergeleitet werden. Dies bietet eine hohe Flexibilität und Kontrolle über den Anfragen- und Antwortfluss in einer Express-Anwendung.
\cite{Express_js_Introduction}

\subsubsection{Routing}
Das Routing, im Kontext von Webanwendungen, spielt eine entscheidende Rolle bei der Bestimmung, wie die Anwendung auf eine Clientanfrage in Bezug auf einen spezifischen Endpoint reagiert. Dieser Prozess ist von essenzieller Bedeutung, um Anfragen an die korrekte Ressource oder den gewünschten Endpunkt innerhalb der Anwendung zu leiten. Um diesen Zweck zu erfüllen, sind zwei entscheidende Informationen erforderlich: der Pfad und die HTTP-Methode.
\newline
Der Pfad definiert die URL-Struktur, anhand derer die Anfrage geroutet wird. Dies ermöglicht die Identifikation des gewünschten Endpunkts oder der Ressource innerhalb der Anwendung. Die HTTP-Methode, andererseits, gibt an, welche Aktion auf dem spezifizierten Pfad ausgeführt werden soll. Es ist wichtig anzumerken, dass eine Route innerhalb einer Webanwendung mehrere HTTP-Funktionen besitzen kann. Dies bedeutet, dass eine bestimmte URL-Ressource oder ein Endpoint für verschiedene HTTP-Anfragen unterschiedliche Reaktionen bieten kann. Dies ermöglicht die Implementierung von CRUD-Operationen (Create, Read, Update, Delete) für bestimmte Ressourcen und bietet somit eine flexible und mächtige Möglichkeit zur Interaktion mit der Anwendung.
\cite{Express_js_basic_routing}
\cite{Express_js_routing}

\subsubsection{Middlewares}
Middleware Funktionen haben Zugriff auf das Request-Object (\textbf{req}), das Response-Object (\textbf{res}) und auf die \textbf{next} Funktion. Mittels next kann nach Abschluss einer Middleware die nächste Middleware aufgerufen werden, dafür gibt es zwei Möglichkeiten.
\newline
In einer Express Applikation ist es möglich 5 verschiedene Arten von Middlewares einzubinden.

\begin{itemize}

    \item \textbf{Application-Level Middleware}
        \newline
        Diese Middleware wird als Instanz des App-Objekts eingebunden, indem man entweder app.use() oder app.METHOD() benutzt. Bei einer Method Funktion, kann man die drei HTTP-Methoden GET, PUT oder POST benutzen. Diese müssen allerdings in kleinbuchstaben geschrieben werden.
        \newline
        Im folgenden Codebeispiel, wird eine Middleware Funktion eingebunden, welche bei jedem Request der an die App geht das aktuelle Datum ausgibt. Nachdem das Datum auf der Konsole ausgegeben wurde, wird next() aufgerufen, was den Request unverändert lässt und falls der Pfad der Syntax user/:id entspricht, in die erste Middleware ausführt. Wenn die ID null entspricht, wird next mit dem Übergabeparameter "route" aufgerufen, was auf die nächste route verweist. In diesem Fall würde man "special" als response bekommen. Ist die ID allerdings ungleich null, wird next ohne Übergabeparameter aufgerufen, wird der Request an die nächste Middleware Funktion weiter gegeben, in diesem Fall würde man "regular" als response erhalten.
        \begin{lstlisting}
            const express = require('express')
            const app = express()

            app.use((req, res, next) => {
                console.log('Time:', Date.now())
                next()
            })
    
            app.get('/user/:id', (req, res, next) => {
                if (req.params.id === '0') next('route')
                else next()
            }, (req, res, next) => {
                res.send('regular')
            })

            app.get('/user/:id', (req, res, next) => {
                res.send('special')
            })
        \end{lstlisting}
    \item \textbf{Router-Level Middleware}
        \newline
        Diese Middleware arbeitet genau gleich wie die Application-Level Middleware, mit dem Unterschied, dass diese eine Instanz des express.Router() ist. Der Grund für diese Art von Middleware ist es, eine Modularität zu erzeugen, welche es möglich macht, eine Anwendung in kleinere Teile aufzuteilen. Dadurch hat man die Möglichkeit ein eigenes Untersystem, wie im unten gezeigten Codebeispiel für alle User requests zu erstellen. Im folgenden Beispiel werden alle /user Anfragen an den userRouter weitergeleitet und in einem externen File beantwortet.
        \begin{lstlisting}
            const userRouter = require('./userRouter')
            
            app.use('/user', userRouter)
        \end{lstlisting}

        \begin{lstlisting}
            router.get('/getAll', (req, res) => {
                res.send('Alle User')
            }
        \end{lstlisting}
    \item \textbf{Error-Handling Middleware}
        \newline
        Die Error-Handling Middleware funktioniert ebenso wie die anderen Middlewares, mit dem kleinen Unterschied, dass 4 Argumente übergeben werden können.
        \begin{lstlisting}
            app.use((err, req, res, next) => {
                console.log(err.stack)
                res.status(500).send('Etwas ist schief gelaufen')
            }
        \end{lstlisting}
    \item \textbf{Built-In Middleware}
        \newline
        Ab Version 4.x verwendet Express nicht mehr Connect und frühere Middleware Funktionen sind in separaten Modulen (third-party middlewares) ausgelagert. Folgende Built-In Middleware-Funktionen sind noch in Express verfügbar:
        \begin{itemize}
            \item \textbf{express.static}
                \newline
                Zur Anzeige von statischem Content, wie zum Beispiel HTML oder Bildern
            \item \textbf{express.json}
                \newline
                Zur Übersetzung von ankommenden JSON requests.
            \item \textbf{express.urlencoded}
                \newline
                Zur Übersetzung von ankommenden URL requests.
        \end{itemize}
    \item \textbf{Third-Party Middleware}
        \newline
        Diese Middleware hat die Aufgabe, einer Express Applikation mehr Funktionalität zu verleihen. Dabei lädt man mittels NPM die gewünschte Middleware aus dem Internet herunter und kann diese anschließend in sein Backend einbauen.
        \begin{lstlisting}
            const express = require('express')
            const app = express()
            const cookieParser = require('cookie-parser')

            app.use(cookieParser())
        \end{lstlisting}
        Es gibt folgende Third-Party Middlewares:\newline
        \begin{tabularx}{0.8\textwidth} { 
            | >{\raggedright\arraybackslash}X 
            | >{\centering\arraybackslash}X 
            | >{\raggedleft\arraybackslash}X | }
        \hline
            body-parser & Parse HTTP request body & express.bodyParser \\
        \hline
            compression & Compress HTTP response & express.compress \\
        \hline
            connect-rid & Generate unique request ID & NA \\
        \hline
            cookie-parser & Parse cookie header and populate req.cookies & express.cookieParser \\
        \hline
            cookie-session & Esatblish cookie-based session & express.cookieSession \\
        \hline
            cors & Enable cross-origin resource sharing (CORS) with various options & NA \\
        \hline
            errorhandler & Development error-handler/debugging & express.errorHandler \\
        \hline
            method-override & Override HTTP methods using header & express.methodOverride \\
        \hline
            morgan & HTTP request logger & express.logger \\
        \hline
            multer & Handle multi-part from data & express.bodyParser \\
        \hline
            response-time & Record HTTP response time & express.responseTime \\
        \hline
            serve-favicon & Serve a favicon & express.favicon \\
        \hline
            serve-static & Serve static files & express.static \\
        \hline
            session & Establish server-based sessions (development only) & express.session \\
        \hline
            timeout & Set a timeout period for HTTP request processing & express.timeout \\
        \hline
            vhost & Create virtual domains & express.vhost \\
        \hline
        \cite{Express_js_third_party_middlewares}
        \end{tabularx}
\end{itemize}
\cite{Express_js_writing_middleware}
\cite{Express_js_using_middleware}
\cite{Express_js_middleware_help_1}

\subsubsection{Überschreiben der Express API}
Die Express API besteht aus dem request und Response Objekt. Diese beitzen verschiedene Funktionen und Übergabeparamter. Man kann die Funktionen der beiden Objekte auf zwei verschiedenen Ebenen verändern. Zum einen kann man diese global, mittels \textbf{express.request} und \textbf{express.response} verändern, aber auch Applikationsspezifisch, durch den Aufruf von \textbf{app.request} und \textbf{app.response}. Eine globale Änderung, wirkt sich auf alle Express-Applikationen im selben Prozess aus, Applikationsspezifische Änderungen können erst nach Erstellung einer neuen App durchgeführt werden und gelten dementsprechend nur für das spezifische Objekt. 

\textbf{Überschreiben von Methoden}
\newline
Um die Express API überschreiben zu können, wird an eine bestehende Funktion eine neue eigens erstellte Methode angehängt.
\begin{lstlisting}
    app.response.sendStatus = function(statusCode, type, message) {
        return this.contentType(type)
            .status(statusCode)
            .send(message)
    }
\end{lstlisting}
In dem oben gezeigten Fall wurde die sendStatus Funktion überschrieben und es wird von nun an eine eigens erstellter Response zurück gegeben. Die überschrieben Funktion kann nun auf folgende Weise aufgerufen werden.
\begin{lstlisting}
    res.sendStatus(404, 'application/json', '{"error":"resource not found"}            
\end{lstlisting}

\textbf{Überschreiben von Properties}
\newline
Properties in der Express API werden in folgende 2 Kategorien eingeteilt: 
\begin{itemize}
    \item 1. Assigned Properties
    \item 2. Defined as Getters
\end{itemize}
Properties aus Kategorie 1, sind dynamisch zugewiesene Eigenschaften und können daher nicht überschrieben werden. Properties aus der 2. Kategorie können mittels Express API extensions API überschrieben werden. Der folgende Code zeigt, wie man den Wert des \textbf{req.ip} Properties verändern kann. In diesem Fall wird nur die Client-IP aus dem request header ausgegeben.
\begin{lstlisting}
    Object.defineProperty(app.request, 'ip', {
        configurable: true,
        enumerable: true,
        get() { return this.get('Client-IP') }
    }
\end{lstlisting}

\textbf{Überschreiben von Prototypes}
\newline
Um die Express API bereitzustellen, müssen die Request und Response Objekte von der selben Prototypenkette abstammen. Standardmäßig sind \textbf{http.IncomingRequest.prototype} und \textbf{http.ServerResponse.prototype} für die Anfragen und Antworten zuständig. Das Überschreiben der Prototypen sollte, außer wenn es nicht anders möglich ist, nur auf der App-Ebene durchgeführt werden.
\begin{lstlisting}
    Object.setPrototypeOf(Object.getPrototypeOf(app.request), FakeRequest.prototype)
    Object.setPrototypeOf(Object.getPrototypeOf(app.response), FakeResponse.prototype)
\end{lstlisting}
In dem oben gezeigten Beispiel, wurde der Prototyp von den http.IncomingRequest/http.ServerResponse auf FakeRequest/FakeResponse umgestellt.
\cite{Express_js_overriding_api}

\subsubsection{Fehlerbehandlung}
